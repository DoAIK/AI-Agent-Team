<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UFO Flight Simulator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #050510;
  font-family: 'Courier New', monospace;
}
canvas {
  display: block;
  width: 100vw;
  height: 100vh;
}
#vignette {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  background: radial-gradient(ellipse at center, transparent 40%, rgba(255,30,30,0.25) 100%);
  z-index: 10;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="vignette"></div>
<script>
// ============================================================
// UFO Flight Simulator - Pure Canvas 2D
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const vignette = document.getElementById('vignette');

// --- Resize ---
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Colors ---
const COL = {
  bg: '#050510',
  cyan: '#00d4ff',
  purple: '#7c3aed',
  red: '#ff4444',
  white: '#ffffff',
  core: '#aaeeff',
};

// --- Input State ---
const keys = {};
const GAME_KEYS = new Set(['KeyW','KeyA','KeyS','KeyD','KeyQ','KeyE','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','ShiftLeft','ShiftRight','Space']);
window.addEventListener('keydown', e => { keys[e.code] = true; if (GAME_KEYS.has(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

function isKey(codes) {
  for (let i = 0; i < codes.length; i++) {
    if (keys[codes[i]]) return true;
  }
  return false;
}

// --- Player / UFO State ---
const player = {
  x: 0,        // world X
  y: 0,        // world Y (horizontal plane)
  z: 300,      // altitude
  vx: 0,
  vy: 0,
  vz: 0,
  angle: 0,    // facing direction (radians)
  angularVel: 0,
  speed: 0,    // scalar speed for HUD
};

const PHYS = {
  thrust: 800,
  reverseThrust: 400,
  turnRate: 3.0,
  friction: 0.975,
  angularFriction: 0.92,
  verticalThrust: 500,
  verticalFriction: 0.96,
  maxSpeed: 1200,
  boostMultiplier: 2.5,
  minAlt: 50,
  maxAlt: 2000,
};

// --- Stars ---
const STAR_COUNT = 400;
const stars = [];
for (let i = 0; i < STAR_COUNT; i++) {
  stars.push({
    x: (Math.random() - 0.5) * 8000,
    y: (Math.random() - 0.5) * 8000,
    z: Math.random() * 1500 + 200,
    size: Math.random() * 2 + 0.5,
    brightness: Math.random() * 0.7 + 0.3,
  });
}

// --- Particles (pool) ---
const MAX_PARTICLES = 600;
const particles = [];
for (let i = 0; i < MAX_PARTICLES; i++) {
  particles.push({ active: false, x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, life: 0, maxLife: 1, size: 2, r: 0, g: 212, b: 255, type: 'exhaust' });
}

function spawnParticle(x, y, z, vx, vy, vz, life, size, r, g, b, type) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) {
      p.active = true;
      p.x = x; p.y = y; p.z = z;
      p.vx = vx; p.vy = vy; p.vz = vz;
      p.life = life; p.maxLife = life;
      p.size = size;
      p.r = r; p.g = g; p.b = b;
      p.type = type;
      return;
    }
  }
}

// --- Environment particles (space dust) ---
const DUST_COUNT = 80;
const dust = [];
for (let i = 0; i < DUST_COUNT; i++) {
  dust.push({
    x: (Math.random() - 0.5) * 4000,
    y: (Math.random() - 0.5) * 4000,
    z: Math.random() * 800 + 100,
    size: Math.random() * 1.5 + 0.3,
  });
}

// --- Buildings on the grid ---
const BUILDING_COUNT = 60;
const buildings = [];
for (let i = 0; i < BUILDING_COUNT; i++) {
  const gridSnap = 200;
  // Pre-generate window pattern to avoid per-frame Math.random flickering
  const bh = Math.random() * 300 + 50;
  const bw = Math.random() * 60 + 30;
  const windowRows = Math.floor(bh / 20);
  const windowCols = Math.floor(bw / 15);
  const windows = [];
  for (let r = 0; r < windowRows; r++) {
    for (let c = 0; c < windowCols; c++) {
      windows.push(Math.random() > 0.4);
    }
  }
  buildings.push({
    x: (Math.floor((Math.random() - 0.5) * 40)) * gridSnap,
    y: (Math.floor((Math.random() - 0.5) * 40)) * gridSnap,
    w: bw,
    d: Math.random() * 60 + 30,
    h: bh,
    color: Math.random() > 0.5 ? COL.cyan : COL.purple,
    windows: windows,
    windowRows: windowRows,
    windowCols: windowCols,
  });
}

// --- Camera shake ---
let shakeIntensity = 0;
let shakeX = 0;
let shakeY = 0;

// --- Speed lines ---
const SPEED_LINES = 40;
const speedLines = [];
for (let i = 0; i < SPEED_LINES; i++) {
  speedLines.push({
    angle: Math.random() * Math.PI * 2,
    dist: Math.random() * 0.3 + 0.3,
    length: Math.random() * 0.1 + 0.05,
    alpha: 0,
  });
}

// --- Game loop timing ---
let lastTime = 0;

// ============================================================
// UPDATE
// ============================================================

function handleInput(dt) {
  const boosting = isKey(['ShiftLeft', 'ShiftRight']);
  const thrustMul = boosting ? PHYS.boostMultiplier : 1;

  // Turning
  let turnInput = 0;
  if (isKey(['KeyA', 'ArrowLeft'])) turnInput -= 1;
  if (isKey(['KeyD', 'ArrowRight'])) turnInput += 1;
  player.angularVel += turnInput * PHYS.turnRate * dt;

  // Forward / Backward
  let thrustInput = 0;
  if (isKey(['KeyW', 'ArrowUp'])) thrustInput += 1;
  if (isKey(['KeyS', 'ArrowDown'])) thrustInput -= 0.5;

  const thrust = thrustInput > 0 ? PHYS.thrust * thrustMul : PHYS.reverseThrust;
  player.vx += Math.cos(player.angle) * thrustInput * thrust * dt;
  player.vy += Math.sin(player.angle) * thrustInput * thrust * dt;

  // Vertical
  let vertInput = 0;
  if (isKey(['KeyQ'])) vertInput += 1;
  if (isKey(['KeyE'])) vertInput -= 1;
  player.vz += vertInput * PHYS.verticalThrust * dt;

  return { boosting, thrustInput, turnInput };
}

function updatePhysics(dt, inputState) {
  // Angular (frame-rate independent damping)
  player.angularVel *= Math.pow(PHYS.angularFriction, dt * 60);
  player.angle += player.angularVel * dt;

  // Horizontal friction (frame-rate independent)
  const hFric = Math.pow(PHYS.friction, dt * 60);
  player.vx *= hFric;
  player.vy *= hFric;

  // Vertical friction (frame-rate independent)
  player.vz *= Math.pow(PHYS.verticalFriction, dt * 60);

  // Speed cap
  const maxSpd = inputState.boosting ? PHYS.maxSpeed * PHYS.boostMultiplier : PHYS.maxSpeed;
  const spd = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
  if (spd > maxSpd) {
    const scale = maxSpd / spd;
    player.vx *= scale;
    player.vy *= scale;
  }

  // Position update
  player.x += player.vx * dt;
  player.y += player.vy * dt;
  player.z += player.vz * dt;

  // Altitude clamp
  if (player.z < PHYS.minAlt) { player.z = PHYS.minAlt; player.vz = Math.abs(player.vz) * 0.3; }
  if (player.z > PHYS.maxAlt) { player.z = PHYS.maxAlt; player.vz = 0; }

  // Store scalar speed for HUD
  player.speed = Math.sqrt(player.vx * player.vx + player.vy * player.vy + player.vz * player.vz);
}

function updateParticles(dt) {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;
    p.life -= dt;
    if (p.life <= 0) { p.active = false; continue; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.z += p.vz * dt;
    const pFric = Math.pow(0.98, dt * 60);
    p.vx *= pFric;
    p.vy *= pFric;
  }
}

function spawnExhaust(boosting, thrustInput) {
  if (thrustInput <= 0 && !boosting) return;
  const count = boosting ? 5 : 2;
  for (let i = 0; i < count; i++) {
    const spread = boosting ? 60 : 30;
    const backAngle = player.angle + Math.PI;
    const speed = 100 + Math.random() * 150;
    const evx = Math.cos(backAngle) * speed + (Math.random() - 0.5) * spread - player.vx * 0.2;
    const evy = Math.sin(backAngle) * speed + (Math.random() - 0.5) * spread - player.vy * 0.2;
    const evz = (Math.random() - 0.5) * 30;
    const life = boosting ? 0.8 + Math.random() * 0.5 : 0.4 + Math.random() * 0.3;
    const sz = boosting ? 3 + Math.random() * 3 : 1.5 + Math.random() * 2;
    if (boosting) {
      spawnParticle(player.x, player.y, player.z, evx, evy, evz, life, sz, 0, 212, 255, 'boost');
    } else {
      spawnParticle(player.x, player.y, player.z, evx, evy, evz, life, sz, 0, 212, 255, 'exhaust');
    }
  }
}

function updateCamera(dt, boosting) {
  // Camera shake on boost
  if (boosting && player.speed > 500) {
    shakeIntensity = Math.min(shakeIntensity + dt * 15, 6);
  } else {
    shakeIntensity *= 0.9;
  }
  shakeX = (Math.random() - 0.5) * shakeIntensity;
  shakeY = (Math.random() - 0.5) * shakeIntensity;

  // Vignette
  vignette.style.opacity = boosting ? Math.min(player.speed / PHYS.maxSpeed * 0.8, 0.8) : 0;
}

// ============================================================
// RENDER
// ============================================================

function clearCanvas() {
  ctx.fillStyle = COL.bg;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// --- Project 3D world pos to screen ---
// Top-down angled camera following the UFO
function worldToScreen(wx, wy, wz) {
  // Offset from player
  const dx = wx - player.x;
  const dy = wy - player.y;
  const dz = wz;

  // Rotate by negative player angle so "forward" is up on screen
  const cosA = Math.cos(-player.angle + Math.PI / 2);
  const sinA = Math.sin(-player.angle + Math.PI / 2);
  const rx = dx * cosA - dy * sinA;
  const ry = dx * sinA + dy * cosA;

  // Perspective: ry is "depth" (forward/back), rx is left/right, dz is height
  // Camera is above and behind the UFO looking forward-down
  const fov = 600;
  const depth = ry + 400; // offset so things in front are positive

  if (depth < 20) return null; // behind camera

  const scale = fov / depth;
  const sx = canvas.width / 2 + rx * scale + shakeX;
  const sy = canvas.height * 0.55 - (wz - player.z * 0.3) * scale + shakeY;

  return { x: sx, y: sy, scale: scale, depth: depth };
}

function renderStars() {
  const boosting = isKey(['ShiftLeft', 'ShiftRight']);
  const spdRatio = Math.min(player.speed / (PHYS.maxSpeed * PHYS.boostMultiplier), 1);

  for (let i = 0; i < STAR_COUNT; i++) {
    const s = stars[i];
    // Parallax: closer stars (lower z layer number) move faster
    const parallax = 1 - (s.z / 2000) * 0.7;
    const wx = s.x + player.x * parallax * 0.3;
    const wy = s.y + player.y * parallax * 0.3;

    // Simple screen projection for stars (they are far away, use simpler method)
    const dx = wx - player.x;
    const dy = wy - player.y;
    const cosA = Math.cos(-player.angle + Math.PI / 2);
    const sinA = Math.sin(-player.angle + Math.PI / 2);
    const rx = dx * cosA - dy * sinA;
    const ry = dx * sinA + dy * cosA;

    // Place stars in upper portion of screen
    const fov = 500;
    const depth = ry + 3000;
    if (depth < 100) continue;
    const scale = fov / depth;
    const sx = canvas.width / 2 + rx * scale * 2;
    const sy = canvas.height * 0.25 - s.z * scale * 0.5;

    if (sx < -20 || sx > canvas.width + 20 || sy < -20 || sy > canvas.height * 0.8) continue;

    const alpha = s.brightness * Math.min(depth / 500, 1);
    const sz = s.size * (1 + scale * 2);

    // Star streak effect when boosting at high speed
    if (boosting && spdRatio > 0.3) {
      const streakLen = spdRatio * 15 * sz;
      ctx.strokeStyle = `rgba(200, 230, 255, ${alpha * 0.7})`;
      ctx.lineWidth = sz * 0.5;
      ctx.beginPath();
      // Streak toward screen center
      const toCenter = Math.atan2(canvas.height * 0.4 - sy, canvas.width / 2 - sx);
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - Math.cos(toCenter) * streakLen, sy - Math.sin(toCenter) * streakLen);
      ctx.stroke();
    }

    ctx.fillStyle = `rgba(200, 230, 255, ${alpha})`;
    ctx.beginPath();
    ctx.arc(sx, sy, Math.max(sz * 0.5, 0.5), 0, Math.PI * 2);
    ctx.fill();

    // Glow for bigger stars
    if (sz > 1.5) {
      ctx.fillStyle = `rgba(200, 230, 255, ${alpha * 0.2})`;
      ctx.beginPath();
      ctx.arc(sx, sy, sz * 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function renderGrid() {
  // Neon grid on the "ground" (z=0)
  const gridSize = 200;
  const gridRange = 15; // reduced range for performance

  // Get player grid cell
  const gx = Math.floor(player.x / gridSize);
  const gy = Math.floor(player.y / gridSize);

  // Draw horizontal lines (constant wy, varying wx)
  for (let j = -gridRange; j <= gridRange; j++) {
    const wy = (gy + j) * gridSize;
    const isAccent = (gy + j) % 5 === 0;
    let started = false;

    for (let i = -gridRange; i <= gridRange; i++) {
      const wx = (gx + i) * gridSize;
      const p = worldToScreen(wx, wy, 0);
      if (!p || p.depth < 20) {
        if (started) { ctx.stroke(); started = false; }
        continue;
      }
      const fogAlpha = Math.max(0, 1 - p.depth / 5000) * 0.6;
      if (fogAlpha < 0.01) {
        if (started) { ctx.stroke(); started = false; }
        continue;
      }
      if (!started) {
        ctx.strokeStyle = isAccent
          ? `rgba(124, 58, 237, ${fogAlpha})`
          : `rgba(0, 212, 255, ${fogAlpha * 0.5})`;
        ctx.lineWidth = isAccent ? 1.5 : 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        started = true;
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    if (started) ctx.stroke();
  }

  // Draw vertical lines (constant wx, varying wy)
  for (let i = -gridRange; i <= gridRange; i++) {
    const wx = (gx + i) * gridSize;
    const isAccent = (gx + i) % 5 === 0;
    let started = false;

    for (let j = -gridRange; j <= gridRange; j++) {
      const wy = (gy + j) * gridSize;
      const p = worldToScreen(wx, wy, 0);
      if (!p || p.depth < 20) {
        if (started) { ctx.stroke(); started = false; }
        continue;
      }
      const fogAlpha = Math.max(0, 1 - p.depth / 5000) * 0.6;
      if (fogAlpha < 0.01) {
        if (started) { ctx.stroke(); started = false; }
        continue;
      }
      if (!started) {
        ctx.strokeStyle = isAccent
          ? `rgba(124, 58, 237, ${fogAlpha})`
          : `rgba(0, 212, 255, ${fogAlpha * 0.5})`;
        ctx.lineWidth = isAccent ? 1.5 : 1;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        started = true;
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    if (started) ctx.stroke();
  }
}

function renderBuildings() {
  // Sort by depth for proper draw order
  const projected = [];
  for (let i = 0; i < BUILDING_COUNT; i++) {
    const b = buildings[i];
    const pBase = worldToScreen(b.x, b.y, 0);
    const pTop = worldToScreen(b.x, b.y, b.h);
    if (pBase && pTop && pBase.depth > 50 && pBase.depth < 4000) {
      projected.push({ b, pBase, pTop, depth: pBase.depth });
    }
  }
  projected.sort((a, b) => b.depth - a.depth);

  for (const { b, pBase, pTop, depth } of projected) {
    const fogAlpha = Math.max(0, 1 - depth / 4000);
    if (fogAlpha < 0.02) continue;

    const wHalf = b.w * pBase.scale * 0.5;
    const baseY = pBase.y;
    const topY = pTop.y;
    const cx = pBase.x;

    // Building body
    ctx.fillStyle = `rgba(8, 8, 25, ${fogAlpha * 0.9})`;
    ctx.fillRect(cx - wHalf, topY, wHalf * 2, baseY - topY);

    // Building outline
    const color = b.color === COL.cyan ? `0, 212, 255` : `124, 58, 237`;
    ctx.strokeStyle = `rgba(${color}, ${fogAlpha * 0.6})`;
    ctx.lineWidth = 1;
    ctx.strokeRect(cx - wHalf, topY, wHalf * 2, baseY - topY);

    // Window lights (using pre-generated pattern)
    if (fogAlpha > 0.15 && wHalf > 5) {
      const pixelH = baseY - topY;
      const pixelW = wHalf * 2;
      const rowH = pixelH / b.windowRows;
      const colW = pixelW / b.windowCols;
      ctx.fillStyle = `rgba(${color}, ${fogAlpha * 0.3})`;
      for (let r = 0; r < b.windowRows; r++) {
        for (let c = 0; c < b.windowCols; c++) {
          if (b.windows[r * b.windowCols + c]) {
            ctx.fillRect(cx - wHalf + c * colW + 2, topY + r * rowH + 2, Math.max(colW - 4, 2), Math.max(rowH - 4, 2));
          }
        }
      }
    }

    // Rooftop glow
    ctx.fillStyle = `rgba(${color}, ${fogAlpha * 0.4})`;
    ctx.fillRect(cx - 2, topY - 3, 4, 3);
  }
}

function renderParticlesPass() {
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const p = particles[i];
    if (!p.active) continue;

    const sp = worldToScreen(p.x, p.y, p.z);
    if (!sp || sp.depth < 20) continue;

    const lifeRatio = p.life / p.maxLife;
    const alpha = lifeRatio * 0.8;
    const sz = p.size * sp.scale * 30;

    if (sz < 0.3) continue;

    ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha})`;
    ctx.beginPath();
    ctx.arc(sp.x, sp.y, Math.max(sz, 0.5), 0, Math.PI * 2);
    ctx.fill();

    // Glow
    if (sz > 1) {
      ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha * 0.3})`;
      ctx.beginPath();
      ctx.arc(sp.x, sp.y, sz * 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function renderDust() {
  for (let i = 0; i < DUST_COUNT; i++) {
    const d = dust[i];
    const parallax = 0.5;
    const wx = d.x + player.x * parallax;
    const wy = d.y + player.y * parallax;

    const sp = worldToScreen(wx, wy, d.z + player.z * 0.5);
    if (!sp || sp.depth < 50) continue;

    const fogAlpha = Math.max(0, 1 - sp.depth / 3000) * 0.3;
    ctx.fillStyle = `rgba(200, 220, 255, ${fogAlpha})`;
    ctx.beginPath();
    ctx.arc(sp.x, sp.y, d.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

function renderUFO() {
  const cx = canvas.width / 2 + shakeX;
  const cy = canvas.height * 0.55 + shakeY;
  const boosting = isKey(['ShiftLeft', 'ShiftRight']);
  const spdRatio = Math.min(player.speed / PHYS.maxSpeed, 1);

  // Banking: tilt based on angular velocity
  const bank = player.angularVel * 8;
  const bankScale = Math.max(0.3, 1 - Math.abs(bank) * 0.15);

  const baseRadius = 22;
  const radiusX = baseRadius * bankScale;
  const radiusY = baseRadius * 0.5;

  // Boost size increase
  const boostGrow = boosting ? 1.15 : 1;

  ctx.save();
  ctx.translate(cx, cy);

  // Outer glow
  const glowSize = (boosting ? 60 : 40) * boostGrow;
  const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, glowSize);
  gradient.addColorStop(0, `rgba(0, 212, 255, ${boosting ? 0.3 : 0.15})`);
  gradient.addColorStop(0.5, `rgba(0, 212, 255, ${boosting ? 0.1 : 0.05})`);
  gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
  ctx.fill();

  // UFO ring (outer)
  ctx.strokeStyle = boosting ? `rgba(0, 230, 255, 0.9)` : `rgba(0, 212, 255, 0.7)`;
  ctx.lineWidth = boosting ? 3 : 2;
  ctx.beginPath();
  ctx.ellipse(0, 0, radiusX * boostGrow, radiusY * boostGrow, 0, 0, Math.PI * 2);
  ctx.stroke();

  // UFO ring glow
  ctx.strokeStyle = `rgba(0, 212, 255, 0.2)`;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.ellipse(0, 0, (radiusX + 3) * boostGrow, (radiusY + 2) * boostGrow, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Inner ring
  ctx.strokeStyle = `rgba(124, 58, 237, ${boosting ? 0.7 : 0.4})`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, radiusX * 0.6 * boostGrow, radiusY * 0.6 * boostGrow, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Core
  const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 8 * boostGrow);
  coreGrad.addColorStop(0, boosting ? '#ffffff' : '#aaeeff');
  coreGrad.addColorStop(0.5, boosting ? 'rgba(0, 230, 255, 0.8)' : 'rgba(0, 212, 255, 0.6)');
  coreGrad.addColorStop(1, 'rgba(0, 212, 255, 0)');
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(0, 0, 8 * boostGrow, 0, Math.PI * 2);
  ctx.fill();

  // Direction indicator (small arrow pointing forward = up on screen)
  ctx.strokeStyle = `rgba(0, 212, 255, 0.5)`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(0, -radiusY * boostGrow - 6);
  ctx.lineTo(-4, -radiusY * boostGrow - 2);
  ctx.moveTo(0, -radiusY * boostGrow - 6);
  ctx.lineTo(4, -radiusY * boostGrow - 2);
  ctx.stroke();

  ctx.restore();
}

function renderSpeedLines() {
  const spdRatio = player.speed / (PHYS.maxSpeed * PHYS.boostMultiplier);
  if (spdRatio < 0.2) return;

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  const maxLen = Math.max(canvas.width, canvas.height) * 0.5;
  const alpha = (spdRatio - 0.2) * 1.2;

  for (let i = 0; i < SPEED_LINES; i++) {
    const sl = speedLines[i];
    const dist = sl.dist * maxLen;
    const len = sl.length * maxLen * spdRatio;

    const x1 = cx + Math.cos(sl.angle) * dist;
    const y1 = cy + Math.sin(sl.angle) * dist;
    const x2 = cx + Math.cos(sl.angle) * (dist + len);
    const y2 = cy + Math.sin(sl.angle) * (dist + len);

    ctx.strokeStyle = `rgba(200, 230, 255, ${alpha * 0.3 * sl.length})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }
}

function renderHUD() {
  const boosting = isKey(['ShiftLeft', 'ShiftRight']);
  const spdRatio = player.speed / (PHYS.maxSpeed * PHYS.boostMultiplier);

  ctx.save();

  // Speed meter
  const hudX = 30;
  const hudY = 30;

  ctx.font = '12px Courier New';
  ctx.fillStyle = `rgba(0, 212, 255, 0.7)`;
  ctx.fillText('SPEED', hudX, hudY);

  const speedVal = Math.round(player.speed);
  ctx.font = 'bold 24px Courier New';
  ctx.fillStyle = boosting ? `rgba(255, 100, 100, 0.9)` : `rgba(0, 212, 255, 0.9)`;
  ctx.fillText(String(speedVal).padStart(4, '0'), hudX, hudY + 25);

  // Speed bar
  const barW = 150;
  const barH = 4;
  const barY = hudY + 32;
  ctx.fillStyle = `rgba(0, 212, 255, 0.15)`;
  ctx.fillRect(hudX, barY, barW, barH);
  ctx.fillStyle = boosting ? `rgba(255, 80, 80, 0.7)` : `rgba(0, 212, 255, 0.7)`;
  ctx.fillRect(hudX, barY, barW * Math.min(spdRatio, 1), barH);

  // Altitude
  ctx.font = '12px Courier New';
  ctx.fillStyle = `rgba(0, 212, 255, 0.7)`;
  ctx.fillText('ALT', hudX, barY + 22);
  ctx.font = 'bold 18px Courier New';
  ctx.fillStyle = `rgba(0, 212, 255, 0.9)`;
  ctx.fillText(String(Math.round(player.z)).padStart(4, '0'), hudX, barY + 42);

  // Boost indicator
  if (boosting) {
    ctx.font = 'bold 14px Courier New';
    ctx.fillStyle = `rgba(255, 80, 80, ${0.6 + Math.sin(Date.now() * 0.01) * 0.3})`;
    ctx.fillText('>> BOOST <<', hudX, barY + 62);
  }

  // Controls help (bottom right)
  ctx.font = '11px Courier New';
  ctx.fillStyle = 'rgba(0, 212, 255, 0.35)';
  const helpX = canvas.width - 200;
  const helpY = canvas.height - 120;
  const controls = [
    'W/S  - Thrust / Brake',
    'A/D  - Turn L/R',
    'Q/E  - Up / Down',
    'Shift - Boost',
  ];
  for (let i = 0; i < controls.length; i++) {
    ctx.fillText(controls[i], helpX, helpY + i * 18);
  }

  ctx.restore();
}

// ============================================================
// MAIN GAME LOOP
// ============================================================

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  // Clamp delta to avoid spiral of death
  if (dt > 0.1) dt = 0.1;

  // --- Update ---
  const inputState = handleInput(dt);
  updatePhysics(dt, inputState);
  spawnExhaust(inputState.boosting, inputState.thrustInput);
  updateParticles(dt);
  updateCamera(dt, inputState.boosting);

  // --- Render ---
  clearCanvas();
  renderStars();
  renderGrid();
  renderBuildings();
  renderDust();
  renderParticlesPass();
  renderUFO();
  renderSpeedLines();
  renderHUD();

  requestAnimationFrame(gameLoop);
}

// --- Start ---
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
